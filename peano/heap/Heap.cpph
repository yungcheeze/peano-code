#include <limits>
#include <memory.h> 


#include "tarch/Assertions.h"
#include "tarch/services/ServiceRepository.h"


#include "tarch/services/ServiceFactory.h"


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
tarch::logging::Log peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::_log("peano::heap::Heap");


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::Heap()
  : _heapData(), _freedHeapIndices(), _nextIndex(0)
  #ifdef Parallel
  , _neighbourDataExchangerTag(tarch::parallel::Node::reserveFreeTag("heap[neighbour]"))
  , _masterWorkerExchanger("master-worker-exchanger", tarch::parallel::Node::reserveFreeTag("heap[master-worker]"))
  , _joinForkExchanger("join/fork-exchanger", tarch::parallel::Node::reserveFreeTag("heap[join/fork]"))
  , _neighbourDataExchanger()
  #endif
  ,_maximumNumberOfHeapEntries(0)
  ,_numberOfHeapAllocations(0)
  ,_numberOfHeapFrees(0)
  ,_name("<heap name not set>")
  #ifdef PackedEmptyHeapMessages
  ,_numberOfNeighbourDataCompressedEmptyMessages()
  #endif
{
  #ifdef Parallel
  if (SendReceiveTask<Data>::MPIData::Datatype==0) {
    SendReceiveTask<Data>::MPIData::initDatatype();
  }
  if(peano::heap::records::MetaInformation::Datatype==0) {
    peano::heap::records::MetaInformation::initDatatype();
  }
  #endif

  tarch::services::ServiceRepository::getInstance().addService( this, "peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>" );
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::~Heap() {
  deleteAllData();
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::deleteAllData() {
  for(typename std::map<int, std::vector<Data>*>::iterator i = _heapData.begin(); i != _heapData.end(); i++) {
    assertionMsg((*i).second != 0, _name << ": Null-pointer was stored in heap data map.");
    delete (*i).second;
  }
  _heapData.clear();

  #ifdef Parallel
  _neighbourDataExchanger.clear();
  #endif
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::plotStatistics() const {
  if(_name != "") {
    logInfo("plotStatistics()", "Statistics for " << _name);
  }
  logInfo("plotStatistics()", "size of heap: " << _heapData.size() << " entries" );
  logInfo("plotStatistics()", "freed but not reassigned heap indices: " << _freedHeapIndices.size() );

  logInfo("plotStatistics()", "maximum number of allocated heap entries: " << _maximumNumberOfHeapEntries );
  logInfo("plotStatistics()", "number of heap allocations: " << _numberOfHeapAllocations );
  logInfo("plotStatistics()", "number of heap frees: " << _numberOfHeapFrees );

  #ifdef Parallel
  _masterWorkerExchanger.plotStatistics();
  _joinForkExchanger.plotStatistics();

  for (
    typename std::map<int, NeighbourDataExchanger>::const_iterator p = _neighbourDataExchanger.begin();
    p != _neighbourDataExchanger.end();
    p++
  ) {
    p->second.plotStatistics();
  }
  #endif
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::clearStatistics() {
  _maximumNumberOfHeapEntries   = 0;
  _numberOfHeapAllocations      = 0;
  _numberOfHeapFrees            = 0;

  #ifdef Parallel
  _masterWorkerExchanger.clearStatistics();
  _joinForkExchanger.clearStatistics();

  for (
    typename std::map<int, NeighbourDataExchanger>::iterator p = _neighbourDataExchanger.begin();
    p != _neighbourDataExchanger.end();
    p++
  ) {
    p->second.clearStatistics();
  }
  #endif
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>& peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::getInstance() {
  static peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger> instance;
  return instance;
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
int peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::createData(int numberOfEntries) {
  logTraceInWith1Argument( "createData()", numberOfEntries );

  int index;
  if (_freedHeapIndices.empty()) {
    index = _nextIndex;
    _nextIndex++;
  }
  else {
    index = _freedHeapIndices.front();
    _freedHeapIndices.pop_front();
  }

  assertionMsg(_heapData.find(index) == _heapData.end(), "heap entry does exist already.");
  _heapData.insert( typename HeapContainer::value_type(index,new std::vector<Data>(numberOfEntries)) );

  assertionMsg(_heapData.find(index) != _heapData.end(), "insertion of heap data not successful.");
  assertion(index >= 0);

  _numberOfHeapAllocations += 1.0;

  if(static_cast<int>(_heapData.size()) > _maximumNumberOfHeapEntries) {
    _maximumNumberOfHeapEntries = static_cast<int>(_heapData.size());
  }

  logTraceOutWith2Arguments("createData()", index, _numberOfHeapAllocations);
  return index;
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
std::vector<Data>& peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::getData(int index) {
  #ifdef Asserts
  std::string message = "Trying to get heap data for unknown index. Has the index been initialized correctly?";
  #endif
  assertion4(_heapData.find(index) != _heapData.end(), _name, message, index, _heapData.size());
  assertionMsg(_heapData[index] != 0, _name << ": Null-pointer was stored in heap data map");
  return *(_heapData[index]);
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
const std::vector<Data>& peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::getData(int index) const {
  #ifdef Asserts
  std::string message = "Trying to get heap data for unknown index. Has the index been initialized correctly?";
  #endif
  assertion4(_heapData.find(index) != _heapData.end(), _name, message, index, _heapData.size());
  assertionMsg(_heapData[index] != 0, _name << ": Null-pointer was stored in heap data map");
  return *(_heapData[index]);
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::moveData( int toIndex, int fromIndex ) {
  assertion4(_heapData.find(toIndex) != _heapData.end(), _name, toIndex, fromIndex, _heapData.size());
  assertion4(_heapData.find(fromIndex) != _heapData.end(), _name, toIndex, fromIndex, _heapData.size());

  _heapData[toIndex]->insert( _heapData[toIndex]->end(), _heapData[fromIndex]->begin(), _heapData[fromIndex]->end() );
  _heapData[fromIndex]->clear();
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
bool peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::isValidIndex(int index) const {
  return _heapData.find(index) != _heapData.end();
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::deleteData(int index) {
  logTraceInWith2Arguments("deleteData(int)", _name, index);

  #ifdef Asserts
  std::string message = "Trying to get heap data for unknown index. Has the index been initialized correctly?";
  #endif
  assertion4(_heapData.find(index) != _heapData.end(), _name, message, index, _heapData.size());
  assertionMsg(_heapData[index] != 0, _name << ": Null-pointer was stored in heap data map");

  _heapData[index]->clear();
  delete _heapData[index];
  _heapData.erase(index);

  _freedHeapIndices.push_back(index);
  _numberOfHeapFrees++;

  logTraceOut("deleteData(int)");
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
int peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::getNumberOfAllocatedEntries() const {
  return _heapData.size();
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::restart() {
  deleteAllData();
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::shutdown() {
  deleteAllData();
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::setName(std::string name) {
  _name = name;
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::sendData(
  const std::vector< Data >&                    data,
  int                                           toRank,
  const tarch::la::Vector<DIMENSIONS, double>&  position,
  int                                           level,
  MessageType                                   messageType
) {
  logTraceInWith6Arguments( "sendData(...)", _name, toRank, position, level, messageType, data.size() );

  #ifdef Parallel
  switch (messageType) {
    case NeighbourCommunication:
      if (_neighbourDataExchanger.count(toRank)==0) {
        _neighbourDataExchanger.insert(
          std::pair<int, NeighbourDataExchanger>(
            toRank,
            NeighbourDataExchanger("heap-neighbour",_neighbourDataExchangerTag,toRank)
          )
        );
      }
      _neighbourDataExchanger[toRank].sendData(data,position,level);
      break;
    case ForkOrJoinCommunication:
      _joinForkExchanger.sendData(data,toRank,position,level);
      break;
    case MasterWorkerCommunication:
      _masterWorkerExchanger.sendData(data,toRank,position,level);
      break;
  }



  #ifdef PackedEmptyHeapMessages
  if(messageType == NeighbourCommunication) {
    if(data.size() == 0) {
      compressZeroLengthMessage(toRank);
      return;
    } else {
      sendCompressedEmptyMessages(toRank, position, level);
    }
  }
  #endif
  #endif

  logTraceOut( "sendData(...)" );
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::sendData(
  int                                           index,
  int                                           toRank,
  const tarch::la::Vector<DIMENSIONS, double>&  position,
  int                                           level,
  MessageType                                   messageType
) {
  logTraceInWith6Arguments( "sendData(...)", _name, index, toRank, position, level, messageType );

  sendData( getData(index), toRank, position, level, messageType );

  logTraceOutWith1Argument( "sendData(...)", getData(index).size() );
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
std::vector< Data > peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::receiveData(
  int                                           fromRank,
  const tarch::la::Vector<DIMENSIONS, double>&  position,
  int                                           level,
  MessageType                                   messageType
) {
  #ifdef Parallel
  switch (messageType) {
    case NeighbourCommunication:
      assertion4( _neighbourDataExchanger.count(fromRank)==1, fromRank, position, level, messageType );
      return _neighbourDataExchanger[fromRank].receiveData(position,level);
      break;
    case ForkOrJoinCommunication:
      return _joinForkExchanger.receiveData(fromRank,position,level);
      break;
    case MasterWorkerCommunication:
      return _masterWorkerExchanger.receiveData(fromRank,position,level);
      break;
  }
  return std::vector< Data >();
  #endif
  return std::vector< Data >();
}



template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
int peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::receiveData(
  int                                           index,
  int                                           fromRank,
  const tarch::la::Vector<DIMENSIONS, double>&  position,
  int                                           level,
  MessageType                                   messageType
) {
  const std::vector< Data >  receivedData = receiveData(fromRank, position, level, messageType);
  std::vector< Data >&       localData    = getData(index);
  localData.insert( localData.end(), receivedData.begin(), receivedData.end() );
  return static_cast<int>( receivedData.size() );
}




template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::receiveDanglingMessages() {
  #ifdef Parallel
  for (
    typename std::map<int, NeighbourDataExchanger>::iterator p = _neighbourDataExchanger.begin();
    p != _neighbourDataExchanger.end();
    p++
  ) {
    p->second.receiveDanglingMessages();
  }

  _masterWorkerExchanger.receiveDanglingMessages();
  _joinForkExchanger.receiveDanglingMessages();
  #endif
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
std::string peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::toString() const {
  std::ostringstream msg;

  msg << "(name=" << _name
      << ",heap-map-size=" << _heapData.size()
      << ")";

  return msg.str();
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::startToSendData(bool isTraversalInverted) {
  logTraceInWith1Argument( "startToSendData(bool)", _name );

  #ifdef Parallel
  _masterWorkerExchanger.startToSendData();
  _joinForkExchanger.startToSendData();

  for (
    typename std::map<int, NeighbourDataExchanger>::iterator p = _neighbourDataExchanger.begin();
    p != _neighbourDataExchanger.end();
    p++
  ) {
    p->second.startToSendData(isTraversalInverted);
  }
  #endif

  logTraceOut( "startToSendData(bool)" );
}


template <class Data, class MasterWorkerExchanger, class JoinForkExchanger, class NeighbourDataExchanger>
void peano::heap::Heap<Data, MasterWorkerExchanger, JoinForkExchanger, NeighbourDataExchanger>::finishedToSendData() {
  logTraceInWith1Argument( "finishedToSendData()", _name );

  #ifdef PackedEmptyHeapMessages
  sendAllCompressedEmptyMessages();
  #endif

  #ifdef Parallel
  _masterWorkerExchanger.finishedToSendData();
  _joinForkExchanger.finishedToSendData();

  for (
    typename std::map<int, NeighbourDataExchanger>::iterator p = _neighbourDataExchanger.begin();
    p != _neighbourDataExchanger.end();
    p++
  ) {
    p->second.finishedToSendData();
  }
  #endif

  logTraceOut( "finishedToSendData()" );
}
