#include "peano/datatraversal/ActionSetTraversalLoop.h"
#include "peano/datatraversal/dForLoop.h"
#include "tarch/multicore/MulticoreDefinitions.h"
#include "peano/utils/PeanoOptimisations.h"



template <class LoopBody>
std::string peano::datatraversal::SingleLevelCellLoop<LoopBody>::toString(ParallelisationStrategy strategy) {
  switch (strategy) {
    case Serial:
      return "serial";
      break;
    case NoColouring:
      return "no-colouring";
      break;
    case TwoPowerDColouring:
      return "two-power-d-colouring";
      break;
    case SixPowerDColouring:
      return "six-power-d-colouring";
      break;
  }
  return "undef";
}



template <class LoopBody>
peano::datatraversal::SingleLevelCellLoop<LoopBody>::SingleLevelCellLoop(
  const tarch::la::Vector<DIMENSIONS,int>&  range,
  LoopBody&                                 loopBody,
  int                                       grainSize,
  ParallelisationStrategy                   parallelisationStrategy
) {
  assertion( tarch::la::volume(range)!=0 );

  #if defined(SharedMemoryParallelisation)
  if (grainSize==0) {
    parallelisationStrategy = Serial;
  }

  switch (parallelisationStrategy) {
    case Serial:
      runSequentially(loopBody,range);
      break;
    case NoColouring:
      runParallelWithoutColouring(loopBody,range,grainSize);
      break;
    case TwoPowerDColouring:
      runParallelWithColouring(loopBody,range,grainSize,false);
      break;
    case SixPowerDColouring:
      runParallelWithColouring(loopBody,range,grainSize,true);
      break;
  }
  #else
  runSequentially(loopBody,range);
  #endif
}


template <class LoopBody>
void peano::datatraversal::SingleLevelCellLoop<LoopBody>::runSequentially(
  LoopBody&                                 loopBody,
  const tarch::la::Vector<DIMENSIONS,int>&  range
) {
  dfor(currentCell,range) {
    loopBody(currentCell);
  }
}


template <class LoopBody>
void peano::datatraversal::SingleLevelCellLoop<LoopBody>::runParallelWithoutColouring(
  LoopBody&                                 loopBody,
  const tarch::la::Vector<DIMENSIONS,int>&  range,
  int                                       grainSize
) {
  typename peano::datatraversal::dForLoop< LoopBody>::dForLoop( range, loopBody, grainSize, false );
}


template <class LoopBody>
void peano::datatraversal::SingleLevelCellLoop<LoopBody>::runParallelWithColouring(
  LoopBody&                                 loopBody,
  const tarch::la::Vector<DIMENSIONS,int>&  range,
  int                                       grainSize,
  bool                                      useSixPowerDColouring
) {
  const int colouringAlongOneAxis = useSixPowerDColouring ? 6 : 2;

  dForLoopInstance loopInstance(loopBody,0,colouringAlongOneAxis);
  dfor(k,colouringAlongOneAxis) {
    tarch::la::Vector<DIMENSIONS,int> localRange = range;
    for (int d=0; d<DIMENSIONS; d++) {
      const int rangeModColouring = localRange(d)%colouringAlongOneAxis;
      if (rangeModColouring!=0 && k(d)<rangeModColouring) {
        localRange(d) = localRange(d) / colouringAlongOneAxis + 1;
      }
      else {
        localRange(d) /= colouringAlongOneAxis;
      }
      assertion4( localRange(d)>=1, range, localRange, k, grainSize );
    }
    loopInstance.setOffset(k);
    #ifdef SharedTBB
    tbb::parallel_reduce( dForRange( localRange, grainSize ), loopInstance );
    #elif defined(SharedMemoryParallelisation)
    #error not implemented yet
    #endif
  }
}



template <class LoopBody>
peano::datatraversal::SingleLevelCellLoop<LoopBody>::dForLoopInstance::dForLoopInstance( const LoopBody& loopBody, const tarch::la::Vector<DIMENSIONS,int>& offset, int padding ):
  _loopBody(loopBody),
  _offset(offset),
  _padding(padding) {
  assertion1( _padding>=2, padding );
}


template <class LoopBody>
peano::datatraversal::SingleLevelCellLoop<LoopBody>::dForLoopInstance::dForLoopInstance( const dForLoopInstance& instance, SplitFlag ):
  _loopBody(instance._loopBody),
  _offset(instance._offset),
  _padding(instance._padding) {
  for (int d=0; d<DIMENSIONS; d++) {
    assertion2( _offset(d)>=0, _offset, _padding );
    assertion2( _offset(d)<_padding, _offset, _padding);
  }
}


template <class LoopBody>
void peano::datatraversal::SingleLevelCellLoop<LoopBody>::dForLoopInstance::operator() (const dForRange& range) {
  dfor(i,range.getRange()) {
    _loopBody( (i + range.getOffset())*_padding + _offset );
  }
}


template <class LoopBody>
void peano::datatraversal::SingleLevelCellLoop<LoopBody>::dForLoopInstance::join(const dForLoopInstance&  with) {
}


template <class LoopBody>
void peano::datatraversal::SingleLevelCellLoop<LoopBody>::dForLoopInstance::setOffset(const tarch::la::Vector<DIMENSIONS,int>&  offset) {
    _offset = offset;
}
