#include "peano/datatraversal/ActionSetTraversalLoop.h"
#include "tarch/multicore/MulticoreDefinitions.h"
#include "peano/utils/PeanoOptimisations.h"


template <class LoopBody>
peano::datatraversal::SingleLevelCellLoop<LoopBody>::SingleLevelCellLoop(
  const tarch::la::Vector<DIMENSIONS,int>&  range,
  LoopBody&                                 loopBody,
  int                                       grainSize
) {
  assertion( tarch::la::volume(range)!=0 );

  #if defined(SharedMemoryParallelisation)
  if (grainSize>0 && tarch::la::volume(range)>1 ) {
    runParallel(loopBody,range,grainSize);
  }
  else {
    runSequentially(loopBody,range);
  }
  #else
  runSequentially(loopBody,range);
  #endif
}


template <class LoopBody>
void peano::datatraversal::SingleLevelCellLoop<LoopBody>::runSequentially(
  LoopBody&                                 loopBody,
  const tarch::la::Vector<DIMENSIONS,int>&  range
) {
  dfor(currentCell,range) {
    loopBody(currentCell);
  }
}


template <class LoopBody>
void peano::datatraversal::SingleLevelCellLoop<LoopBody>::runParallel(
  LoopBody&                                 loopBody,
  const tarch::la::Vector<DIMENSIONS,int>&  range,
  int                                       grainSize
) {
  for (int d=0; d<DIMENSIONS; d++) {
    assertion2( range(d)>=2, range, grainSize );
  }

  dfor2(k)
    tarch::la::Vector<DIMENSIONS,int> localRange = range;
    for (int d=0; d<DIMENSIONS; d++) {
      if (localRange(d)%2!=0 && k(d)==0) {
        localRange(d) = localRange(d) / 2 + 1;
      }
      else {
        localRange(d) /= 2;
      }
    }
    dForLoopInstance loopInstance(loopBody,k);
    #ifdef SharedTBB
    tbb::parallel_reduce( dForRange( localRange, grainSize ), loopInstance );
    #elif defined(SharedMemoryParallelisation)
    #error not implemented yet
    #endif
  enddforx
}



template <class LoopBody>
peano::datatraversal::SingleLevelCellLoop<LoopBody>::dForLoopInstance::dForLoopInstance( const LoopBody& loopBody, const tarch::la::Vector<DIMENSIONS,int>& offset ):
  _loopBody(loopBody),
  _offset(offset) {
}


template <class LoopBody>
peano::datatraversal::SingleLevelCellLoop<LoopBody>::dForLoopInstance::dForLoopInstance( const dForLoopInstance& instance, SplitFlag ):
  _loopBody(instance._loopBody),
  _offset(instance._offset) {
  for (int d=0; d<DIMENSIONS; d++) {
    assertion1( _offset(d)>=0, _offset );
    assertion1( _offset(d)<=1, _offset );
  }
}


template <class LoopBody>
void peano::datatraversal::SingleLevelCellLoop<LoopBody>::dForLoopInstance::operator() (const dForRange& range) {
  dfor(i,range.getRange()) {
    _loopBody( (i + range.getOffset())*2 + _offset );
  }
}


template <class LoopBody>
void peano::datatraversal::SingleLevelCellLoop<LoopBody>::dForLoopInstance::join(const dForLoopInstance&  with) {
}
