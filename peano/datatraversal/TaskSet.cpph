#include "tarch/Assertions.h"


#if defined(SharedCobra)
#include "tarch/multicore/cobra/Core.h"

#include <cobra/thread.hpp>

#include <memory>
#endif


template <class Functor>
peano::datatraversal::TaskSet::TaskSet(
  Functor&  myTask
) {
  #if defined(SharedTBB)
  typedef GenericTaskWithCopy<Functor> Task;

  Task* tbbTask = new(tbb::task::allocate_root()) Task(myTask);

  tbb::task::enqueue(*tbbTask);

  #elif defined(SharedOMP)
    #pragma omp task shared(myTask)
    {
      Functor copyOfMyTask(myTask);
      copyOfMyTask();
    }
  #elif defined(SharedCobra)
//   ::cobra::thread thread(
//    [=]{
//      Functor copyOfmyTask(myTask);
//      copyOfmyTask();
//    }
//  );
//  thread.detach();
  myTask();
  #else
  myTask();
  #endif
}


template <class Functor0, class Functor1>
peano::datatraversal::TaskSet::TaskSet(
  Functor0&  task0,
  Functor1&  task1,
  int        parallelise
) {
  assertion1( parallelise>=0 && parallelise<=2, parallelise );
  if (parallelise==1) {
    #if defined(SharedTBB)
      typedef GenericTask<Functor0> Task0;
      typedef GenericTask<Functor1> Task1;

      Task0* tbbTask0 = new(tbb::task::allocate_root()) Task0(task0);
      Task1* tbbTask1 = new(tbb::task::allocate_root()) Task1(task1);

      tbb::task_list tbbTaskList;

      tbbTaskList.push_back(*tbbTask0);
      tbbTaskList.push_back(*tbbTask1);

      tbb::task::spawn_root_and_wait(tbbTaskList);
    #elif defined(SharedOMP)
      #pragma omp task shared(task0)
      {
        task0();
      }
      #pragma omp task shared(task1)
      {
        task1();
      }
      #pragma omp taskwait
    #elif defined(SharedCobra)
//      tarch::multicore::cobra::Core::getInstance().getScheduler().call(
//          // & does not seem to work
//        [&](::cobra::continuator& ctr) {
//          ctr.fork<0>([&](::cobra::continuator&){ task0(); });
//          ctr.fork<1>([&](::cobra::continuator&){ task1(); });
//          ctr.join([]{});
//        }
//      );
      task0();
      task1();
    #else
      task0();
      task1();
    #endif
  }
  else {
    task0();
    task1();
  }
}



template <class Functor0, class Functor1, class Functor2>
peano::datatraversal::TaskSet::TaskSet(
  Functor0&  task0,
  Functor1&  task1,
  Functor2&  task2,
  int        parallelise
) {
  assertion1( parallelise>=0 && parallelise<=3, parallelise );
  if (parallelise==1 || parallelise==2) {
    #if defined(SharedTBB)
      typedef GenericTask<Functor0> Task0;
      typedef GenericTask<Functor1> Task1;
      typedef GenericTask<Functor2> Task2;

      Task0* tbbTask0 = new(tbb::task::allocate_root()) Task0(task0);
      Task1* tbbTask1 = new(tbb::task::allocate_root()) Task1(task1);
      Task2* tbbTask2 = new(tbb::task::allocate_root()) Task2(task2);

      tbb::task_list tbbTaskList;

      tbbTaskList.push_back(*tbbTask0);
      tbbTaskList.push_back(*tbbTask1);
      tbbTaskList.push_back(*tbbTask2);

      tbb::task::spawn_root_and_wait(tbbTaskList);
    #elif defined(SharedOMP)
      #pragma omp task shared(task0)
      {
        task0();
      }
      #pragma omp task shared(task1)
      {
        task1();
      }
      #pragma omp task shared(task2)
      {
        task2();
      }
      #pragma omp taskwait
    #elif defined(SharedCobra)
//      tarch::multicore::cobra::Core::getInstance().getScheduler().call(
//        [&](::cobra::continuator& ctr) {
//          ctr.fork<0>([&](::cobra::continuator&){ task0(); });
//          ctr.fork<1>([&](::cobra::continuator&){ task1(); });
//          ctr.fork<2>([&](::cobra::continuator&){ task2(); });
//          ctr.join([]{});
//        }
//      );
      task0();
      task1();
      task2();
    #else
      task0();
      task1();
      task2();
    #endif
  }
  else {
    task0();
    task1();
    task2();
  }
}


#ifdef SharedTBB
template <class Functor>
peano::datatraversal::TaskSet::GenericTask<Functor>::GenericTask(Functor& functor):
  _functor(functor)  {
}


template <class Functor>
tbb::task* peano::datatraversal::TaskSet::GenericTask<Functor>::execute() {
  _functor();
  return 0;
}


template <class Functor>
peano::datatraversal::TaskSet::GenericTaskWithCopy<Functor>::GenericTaskWithCopy(const Functor&  functor):
  _functor(functor)  {
}


template <class Functor>
tbb::task* peano::datatraversal::TaskSet::GenericTaskWithCopy<Functor>::execute() {
  _functor();
  return 0;
}
#endif
