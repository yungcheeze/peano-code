#include "peano/MappingSpecification.h"


template < class Vertex, class Cell, class State, class EventHandle>
tarch::logging::Log peano::grid::nodes::tasks::InvokeEnterCell< Vertex, Cell, State, EventHandle >::_log( "peano::grid::nodes::tasks::InvokeEnterCell" );


template < class Vertex, class Cell, class State, class EventHandle>
peano::grid::nodes::tasks::InvokeEnterCell< Vertex, Cell, State, EventHandle >::InvokeEnterCell(
  State&                                                      state,
  Cell&                                                       fineGridCell,
  Vertex* const                                               fineGridVertices,
  const peano::grid::SingleLevelEnumerator&  fineGridVerticesEnumerator,
  Cell&                                                       coarseGridCell,
  Vertex*const                                                coarseGridVertices,
  const peano::grid::SingleLevelEnumerator&  coarseGridVerticesEnumerator,
  const tarch::la::Vector<DIMENSIONS,int>&                    fineGridPositionOfCell,
  EventHandle&                                                eventHandle
):
  _state(state),
  _fineGridCell(fineGridCell),
  _fineGridVertices(fineGridVertices),
  _fineGridVerticesEnumerator(fineGridVerticesEnumerator),
  _coarseGridCell(coarseGridCell),
  _coarseGridVertices(coarseGridVertices),
  _coarseGridVerticesEnumerator(coarseGridVerticesEnumerator),
  _fineGridPositionOfCell(fineGridPositionOfCell),
  _eventHandle(eventHandle),
  _threadLocalEventHandle(eventHandle)
  #ifdef TrackGridStatistics
  ,
  _innerCells(0),
  _outerCells(0),
  _innerLeafCells(0),
  _outerLeafCells(0)
  #endif
  {
}

template < class Vertex, class Cell, class State, class EventHandle>
void peano::grid::nodes::tasks::InvokeEnterCell< Vertex, Cell, State, EventHandle >::operator() () {
  logTraceInWith1Argument( "operator()", _fineGridCell.toString() );

  // According to the specification, only refined cells where all adjacent
  // vertices are refined are to be excluded. This check is rather expensive,
  // so I do that simple one.
//  const bool InvokeEventAccordingToSpecification =
//    (_threadLocalEventHandle.enterCellSpecification.manipulates == peano::MappingSpecification::WHOLE_TREE) ||
//    (_threadLocalEventHandle.enterCellSpecification.manipulates == peano::MappingSpecification::ONLY_LEAVES && !_fineGridCell.isRefined());

  const bool InvokeEventAccordingToSpecification =
    _threadLocalEventHandle.enterCellSpecification().manipulates != peano::MappingSpecification::Nop;

  #ifdef Parallel
  const bool invokeEvent = _fineGridCell.isInside() && !_fineGridCell.isRemote(_state,true,true);
  if (
    !_fineGridCell.isInside()
    &&
    _fineGridVerticesEnumerator.getLevel() < peano::parallel::loadbalancing::Oracle::getInstance().getRegularLevelAlongBoundary()
    &&
    peano::grid::aspects::VertexStateAnalysis::isOneVertexOutsideDomain(
      _fineGridVertices,
      _fineGridVerticesEnumerator
    )
    &&
    peano::grid::aspects::VertexStateAnalysis::isOneVertexBoundary(
      _fineGridVertices,
      _fineGridVerticesEnumerator
    )
    &&
    peano::grid::aspects::VertexStateAnalysis::doesOneVertexCarryRefinementFlag(
      _fineGridVertices,
      _fineGridVerticesEnumerator,
      Vertex::Records::Refined
    )
  ) {
    dfor2(k)
      if (
        _fineGridVertices[_fineGridVerticesEnumerator(k)].getRefinementControl()==Vertex::Records::Unrefined
        &&
        !_fineGridVertices[_fineGridVerticesEnumerator(k)].isHangingNode()
        &&
        !_fineGridVertices[_fineGridVerticesEnumerator(k)].isRemote( _state, true, false)
      ) {
        logDebug( "operator()", "refine vertex " << _fineGridVertices[_fineGridVerticesEnumerator(k)].toString() << " manually as boundary regularity is set to " << peano::parallel::loadbalancing::Oracle::getInstance().getRegularLevelAlongBoundary() );
        _fineGridVertices[_fineGridVerticesEnumerator(k)].refine();
      }
    enddforx
  }
  #else
  const bool invokeEvent = _fineGridCell.isInside();
  #endif


  if (invokeEvent && InvokeEventAccordingToSpecification) {
    _threadLocalEventHandle.enterCell(
      _fineGridCell,
      _fineGridVertices,
      _fineGridVerticesEnumerator,
      _coarseGridVertices,
      _coarseGridVerticesEnumerator,
      _coarseGridCell,
      _fineGridPositionOfCell
    );

    #ifdef TrackGridStatistics
    if (_fineGridCell.isRefined()) {
      _innerCells += 1.0;
    }
    else {
      _innerLeafCells += 1.0;
    }
    #endif
  }
  else {
    #ifdef TrackGridStatistics
    if (_fineGridCell.isRefined()) {
      _outerCells += 1.0;
    }
    else {
      _outerLeafCells += 1.0;
    }
    #endif
  }

  logTraceOut( "operator()" );
}


template < class Vertex, class Cell, class State, class EventHandle>
peano::grid::nodes::tasks::InvokeEnterCell< Vertex, Cell, State, EventHandle >::~InvokeEnterCell() {
  #ifdef TrackGridStatistics
  _state.incNumberOfOuterCells( _outerCells );
  _state.incNumberOfInnerCells( _innerCells );

  _state.incNumberOfOuterLeafCells( _outerLeafCells );
  _state.incNumberOfInnerLeafCells( _innerLeafCells );
  #endif

  #if defined(SharedMemoryParallelisation)
  _eventHandle.mergeWithWorkerThread( _threadLocalEventHandle );
  #endif
}
