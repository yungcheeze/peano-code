#include "peano/grid/SingleLevelEnumerator.h"

#include "tarch/parallel/NodePool.h"
#include "peano/parallel/AdjacencyList.h"


template <class Vertex>
void peano::grid::aspects::ParallelMerge::mergeWithVertexFromMaster(
  Vertex&        localVertex,
  const Vertex&  masterVertex
) {
  if (
    masterVertex._vertexData.getRefinementControl() == Vertex::Records::Erasing &&
    masterVertex.isAdjacentToDomainOf( tarch::parallel::NodePool::getInstance().getMasterRank() )
  ) {
    localVertex._vertexData.setRefinementControl( Vertex::Records::Erasing );

    // @todo bitte wieder raus
    logInfo( "mergeWithVertexFromMaster(...)", "erase worker's top level vertex, as master is erasing a subtree: " << localVertex.toString() << " [@todo bitte wieder auf Debug umstellen]" );
  }


  // Diesen Fall habe ich mir noch nicht ueberlegt -> der geht aber genau schief, d.h. wir haben ihn jetzt
  // vermutlich muss dann einfach die Adjazenzliste lokal so gesetzt werden, dass kein Master dabei ist
  assertion2(
    !masterVertex.isHangingNode() ||
    (localVertex.getRefinementControl()==Vertex::Records::Unrefined && !localVertex.isAdjacentToRemoteRank()),
    masterVertex.toString(),
    localVertex.toString()
  );

}


template <class Vertex>
void peano::grid::aspects::ParallelMerge::mergeOnDomainBoundary(
  Vertex&        localVertex,
  const Vertex&  neighbourVertex,
  int            neighbourRank
) {
  logTraceInWith3Arguments( "mergeOnDomainBoundary(...)", localVertex, neighbourVertex, neighbourRank );

  #ifdef Debug // if we are not in debug mode, these values are not available.
  assertionVectorNumericalEquals2( localVertex._vertexData.getX(), neighbourVertex._vertexData.getX(),     localVertex.toString(), neighbourVertex.toString() );
  assertionEquals2( localVertex._vertexData.getLevel(),            neighbourVertex._vertexData.getLevel(), localVertex.toString(), neighbourVertex.toString() );
  #endif

  assertionEquals2( localVertex._vertexData.getInsideOutsideDomain(), neighbourVertex._vertexData.getInsideOutsideDomain(), localVertex.toString(), neighbourVertex.toString() );
  assertion1( !localVertex.isHangingNode(),                           localVertex.toString() );

  assertion3( localVertex.getRefinementControl()!=Vertex::Records::Erasing ,                                    localVertex.toString(), neighbourVertex.toString(), tarch::parallel::Node::getInstance().getRank()  );
  assertion3( localVertex.getRefinementControl()!=Vertex::Records::Refining,                                    localVertex.toString(), neighbourVertex.toString(), tarch::parallel::Node::getInstance().getRank()  );
  assertion3( localVertex.getRefinementControl()!=Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing, localVertex.toString(), neighbourVertex.toString(), tarch::parallel::Node::getInstance().getRank()  );

  const bool OnlyNeighbourHasTriggeredRefinement =
    neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::RefinementTriggered &&
    localVertex._vertexData.getRefinementControl()==Vertex::Records::Unrefined;
  const bool OnlyNeighbourHasTriggeredErase =
    neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::EraseTriggered &&
    localVertex._vertexData.getRefinementControl()==Vertex::Records::Refined;
  const bool OnlyLocalHasTriggeredRefinement =
    localVertex._vertexData.getRefinementControl()==Vertex::Records::RefinementTriggered &&
    neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::Unrefined;
  const bool OnlyLocalHasTriggeredErase =
    localVertex._vertexData.getRefinementControl()==Vertex::Records::EraseTriggered &&
    neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::Refined;

  if (OnlyNeighbourHasTriggeredRefinement || OnlyLocalHasTriggeredRefinement) {
    localVertex._vertexData.setRefinementControl( Vertex::Records::RefinementTriggered );
  }
  else if (OnlyNeighbourHasTriggeredErase || OnlyLocalHasTriggeredErase) {
    localVertex._vertexData.setRefinementControl( Vertex::Records::EraseTriggered );
  }
  else {
    assertion2(
         (localVertex._vertexData.getRefinementControl()==neighbourVertex._vertexData.getRefinementControl())
      || (localVertex._vertexData.getRefinementControl()==Vertex::Records::EraseTriggered && neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::Refining)
      || (localVertex._vertexData.getRefinementControl()==Vertex::Records::Refined && neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::Refining)
      || (localVertex._vertexData.getRefinementControl()==Vertex::Records::Unrefined && neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::Erasing)
      || (localVertex._vertexData.getRefinementControl()==Vertex::Records::Unrefined && neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing)
      , localVertex.toString(), neighbourVertex.toString()
    );
  }

  localVertex._vertexData.setNumberOfAdjacentRefinedCells( neighbourVertex._vertexData.getNumberOfAdjacentRefinedCells() );
  
  logTraceOutWith1Argument( "mergeOnDomainBoundary(...)", localVertex );
}


template <class Vertex>
peano::grid::aspects::ParallelMerge::MergeVertexDueToJoinEffect
peano::grid::aspects::ParallelMerge::mergeWithJoinedVertexFromWorker(
  Vertex&        localVertex,
  const Vertex&  workerVertex,
  int            workerRank
) {
  logTraceInWith3Arguments( "mergeWithJoinedVertexFromWorker(...)", localVertex, workerVertex, workerRank );

  MergeVertexDueToJoinEffect result = MasterVertexStateRemainsUnaltered;

  const bool LocalNodeHasNotBeenResponsibleBefore = !localVertex.isAdjacentToDomainOf( tarch::parallel::Node::getInstance().getRank() );

  assertionVectorNumericalEquals3( localVertex._vertexData.getX(), workerVertex._vertexData.getX(),     localVertex.toString(), workerVertex.toString(), workerRank );
  assertionEquals3( localVertex._vertexData.getLevel(),            workerVertex._vertexData.getLevel(), localVertex.toString(), workerVertex.toString(), workerRank );

  assertion4( !localVertex.isHangingNode(),  localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
  assertion4( !workerVertex.isHangingNode(),  localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );

  assertion4(
    LocalNodeHasNotBeenResponsibleBefore ||
    localVertex._vertexData.getInsideOutsideDomain() == workerVertex._vertexData.getInsideOutsideDomain(),
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );

  assertion4(
    workerVertex.getRefinementControl()!=Vertex::Records::EraseTriggered,
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );
  assertion4(
    workerVertex.getRefinementControl()!=Vertex::Records::RefinementTriggered,
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );
  assertion4(
    localVertex.getRefinementControl()!=Vertex::Records::EraseTriggered,
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );
  assertion4(
    localVertex.getRefinementControl()!=Vertex::Records::RefinementTriggered,
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );
  assertion4(
    workerVertex.getRefinementControl()!=Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing,
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );

  // local vertex = unrefined
  if (
    workerVertex.getRefinementControl()==Vertex::Records::Unrefined &&
    localVertex.getRefinementControl()==Vertex::Records::Unrefined
  ) {
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Refining &&
    localVertex.getRefinementControl()==Vertex::Records::Unrefined
  ) {
    assertion4(
      LocalNodeHasNotBeenResponsibleBefore,
      localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
    );
    localVertex._vertexData.setRefinementControl(Vertex::Records::Refining);
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Refined &&
    localVertex.getRefinementControl()==Vertex::Records::Unrefined
  ) {
    assertion4(
      LocalNodeHasNotBeenResponsibleBefore,
      localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
    );
    localVertex._vertexData.setRefinementControl(Vertex::Records::Refining);
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Erasing &&
    localVertex.getRefinementControl()==Vertex::Records::Unrefined
  ) {
    if (LocalNodeHasNotBeenResponsibleBefore) {
      localVertex._vertexData.setRefinementControl(Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing);
    }
    else {
      assertion4( false, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
    }
  }
  // local vertex = refining
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Unrefined &&
    localVertex.getRefinementControl()==Vertex::Records::Refining
  ) {
    assertion4( false, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Refining &&
    localVertex.getRefinementControl()==Vertex::Records::Refining
  ) {
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Refined &&
    localVertex.getRefinementControl()==Vertex::Records::Refining
  ) {
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Erasing &&
    localVertex.getRefinementControl()==Vertex::Records::Refining
  ) {
    assertion4( false, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
  }
  // local vertex = refined
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Unrefined &&
    localVertex.getRefinementControl()==Vertex::Records::Refined
  ) {
    assertion4( false, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Refining &&
    localVertex.getRefinementControl()==Vertex::Records::Refined
  ) {
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Refined &&
    localVertex.getRefinementControl()==Vertex::Records::Refined
  ) {
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Erasing &&
    localVertex.getRefinementControl()==Vertex::Records::Refined
  ) {
    assertion4(
      !LocalNodeHasNotBeenResponsibleBefore,
      localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
    );
    // ich mein dass die richtig ist. Das sollte nicht auftauchen, tuts aber schon mit n=3 bei rotating heat source
    assertion4( false, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
//    localVertex._vertexData.setRefinementControl(Vertex::Records::Erasing);
  }
  // local vertex = erasing
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Unrefined &&
    localVertex.getRefinementControl()==Vertex::Records::Erasing
  ) {
    assertion4( false, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Refining &&
    localVertex.getRefinementControl()==Vertex::Records::Erasing
  ) {
    assertion4( false, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Refined &&
    localVertex.getRefinementControl()==Vertex::Records::Erasing
  ) {
    assertion4( false, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Erasing &&
    localVertex.getRefinementControl()==Vertex::Records::Erasing
  ) {
  }
  // local vertex = RefineDueToJoinThoughWorkerIsAlreadyErasing
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Unrefined &&
    localVertex.getRefinementControl()==Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing
  ) {
    assertion4( false, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Refining &&
    localVertex.getRefinementControl()==Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing
  ) {
    assertion4( false, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Refined &&
    localVertex.getRefinementControl()==Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing
  ) {
    assertion4( false, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
  }
  else if (
    workerVertex.getRefinementControl()==Vertex::Records::Erasing &&
    localVertex.getRefinementControl()==Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing
  ) {
  }
  else {
    assertionMsg( false, "Was nicht sein soll darf auch nicht sein" );
  }

  if (LocalNodeHasNotBeenResponsibleBefore) {
    if (workerVertex.isInside() && localVertex.isOutside()) {
      result = CreateInnerVertexOnMaster;
    }
    if (workerVertex.isBoundary() && localVertex.isOutside()) {
      result = CreateBoundaryVertexOnMaster;
    }

    for (int i=0; i<TWO_POWER_D; i++) {
      const bool entriesAreEqual  = localVertex._vertexData.getAdjacentRanks(i)  == workerVertex._vertexData.getAdjacentRanks(i);
      const bool workersEntryIsMe = workerVertex._vertexData.getAdjacentRanks(i) == tarch::parallel::Node::getInstance().getRank();
      if ( !entriesAreEqual && !workersEntryIsMe) {
        localVertex._vertexData.setAdjacentRanks( i, workerVertex._vertexData.getAdjacentRanks(i) );
      }
      assertion4( localVertex._vertexData.getAdjacentRanks(i)!=peano::parallel::UndefinedNeighbour, localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank() );
    }
  }
  else {
    assertionEquals2( localVertex._vertexData.getInsideOutsideDomain(), workerVertex._vertexData.getInsideOutsideDomain(), localVertex.toString(), workerVertex.toString() );
  }

  localVertex.invalidateAdjacentCellInformation();

  logTraceOutWith2Arguments( "mergeWithJoinedVertexFromWorker(...)", localVertex, result );
  return result;
}


template <class Vertex>
void peano::grid::aspects::ParallelMerge::mergeWithForkedVertexFromMaster(
  Vertex&        localVertex,
  const Vertex&  masterVertex
) {
  logTraceInWith2Arguments( "mergeWithForkedVertexFromMaster(...)", localVertex, masterVertex );

  const bool MasterIsNotResponsibleAnymore = !masterVertex.isAdjacentToDomainOf( tarch::parallel::NodePool::getInstance().getMasterRank() );

  assertionVectorNumericalEquals2( localVertex._vertexData.getX(),     masterVertex._vertexData.getX(),     localVertex.toString(), masterVertex.toString() );
  assertionEquals2(                localVertex._vertexData.getLevel(), masterVertex._vertexData.getLevel(), localVertex.toString(), masterVertex.toString() );

  assertion2( localVertex.isHangingNode() || localVertex._vertexData.getAdjacentCellsHeightOfPreviousIteration() <= -2,  localVertex.toString(), masterVertex.toString() );
  assertion2( localVertex.isHangingNode() || localVertex._vertexData.getAdjacentCellsHeight()                    <= -2,  localVertex.toString(), masterVertex.toString() );
  assertion3( masterVertex.isHangingNode() || masterVertex._vertexData.getAdjacentCellsHeightOfPreviousIteration() <= -2, localVertex.toString(), masterVertex.toString(), toString(static_cast<peano::grid::CellFlags>(masterVertex._vertexData.getAdjacentCellsHeightOfPreviousIteration())) );
  assertion2( masterVertex.isHangingNode() || masterVertex._vertexData.getAdjacentCellsHeight()                    <= -2, localVertex.toString(), masterVertex.toString() );
  assertionEquals2( masterVertex.isHangingNode(), localVertex.isHangingNode(), localVertex.toString(), masterVertex.toString() );

  assertion4(
    MasterIsNotResponsibleAnymore ||
    localVertex._vertexData.getInsideOutsideDomain() == masterVertex._vertexData.getInsideOutsideDomain(),
    localVertex.toString(), masterVertex.toString(), tarch::parallel::NodePool::getInstance().getMasterRank(), tarch::parallel::Node::getInstance().getRank()
  );
  assertion4(
    localVertex.getRefinementControl() == Vertex::Records::Unrefined ||
    localVertex.getRefinementControl() == Vertex::Records::Refining ||
    localVertex.getRefinementControl() == Vertex::Records::RefinementTriggered ||
    localVertex.getRefinementControl() == Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing,
    localVertex.toString(), masterVertex.toString(), tarch::parallel::NodePool::getInstance().getMasterRank(), tarch::parallel::Node::getInstance().getRank()
  );
  assertion4(
    localVertex.getRefinementControl() != Vertex::Records::Erasing,
    localVertex.toString(), masterVertex.toString(), tarch::parallel::NodePool::getInstance().getMasterRank(), tarch::parallel::Node::getInstance().getRank()
  );
  assertion2( masterVertex.isAdjacentToDomainOf(tarch::parallel::Node::getInstance().getRank()), masterVertex.toString(), localVertex.toString() );

  const bool                                          masterIsRefinedLocalVertexIsNot  = masterVertex.getRefinementControl()==Vertex::Records::Refined && localVertex.getRefinementControl()!=Vertex::Records::Refined;
  const bool                                          workerIsRefiningOrTriggeredRefinementWhileMasterVertexIsUnrefined  =
    (localVertex.getRefinementControl()==Vertex::Records::Refining || localVertex.getRefinementControl()==Vertex::Records::RefinementTriggered) &&
    (masterVertex.getRefinementControl()==Vertex::Records::Unrefined || masterVertex.getRefinementControl()==Vertex::Records::Erasing);
  const bool                                          workerHasToRefineTemporarily     =
    (masterVertex.getRefinementControl()==Vertex::Records::Erasing && localVertex.getRefinementControl()==Vertex::Records::Unrefined)
    ||
    (masterVertex.getRefinementControl()==Vertex::Records::Erasing && localVertex.getRefinementControl()==Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing);

  const typename Vertex::Records::InsideOutsideDomain insideOutsideDomainOfLocalVertex = localVertex._vertexData.getInsideOutsideDomain();

  assertion3(
    !workerIsRefiningOrTriggeredRefinementWhileMasterVertexIsUnrefined || MasterIsNotResponsibleAnymore,
    masterVertex.toString(),
    localVertex.toString(),
    tarch::parallel::Node::getInstance().getRank()
  );

  localVertex._vertexData.setIsHangingNode(       masterVertex._vertexData.getIsHangingNode() );
  localVertex._vertexData.setRefinementControl(   masterVertex._vertexData.getRefinementControl() );
  localVertex._vertexData.setInsideOutsideDomain( masterVertex._vertexData.getInsideOutsideDomain() );
  localVertex._vertexData.setAdjacentRanks(       masterVertex._vertexData.getAdjacentRanks() );

  #ifdef Debug
  localVertex._vertexData.setX( masterVertex._vertexData.getX() );
  localVertex._vertexData.setLevel( masterVertex._vertexData.getLevel() );
  #endif

  if (MasterIsNotResponsibleAnymore) {
    localVertex._vertexData.setInsideOutsideDomain(insideOutsideDomainOfLocalVertex);
  }
  else {
    assertionEquals2( localVertex._vertexData.getInsideOutsideDomain(), masterVertex._vertexData.getInsideOutsideDomain(),                    localVertex.toString(), masterVertex.toString() );
  }

  if (masterIsRefinedLocalVertexIsNot) {
    localVertex._vertexData.setRefinementControl( Vertex::Records::Refining );
  }
  else if (workerIsRefiningOrTriggeredRefinementWhileMasterVertexIsUnrefined) {
    // the local vertex was already refining. That can happen if and only if
    // the create event has triggered a refinement. In that case, Peano tries
    // to refine immediately, i.e. not in two sweeps. As we are forking however
    // we have disable this immediate refine here manually - the master did not
    // do the same thing, as the vertex is already remote on the master. So we
    // reset the refining to refinement-triggered.
    localVertex._vertexData.setRefinementControl( Vertex::Records::RefinementTriggered );
    logDebug( "mergeWithForkedVertexFromMaster(...)","manually reset refinement state of " << localVertex.toString() );
  }
  else if (workerHasToRefineTemporarily) {
    localVertex._vertexData.setRefinementControl( Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing );
  }

  localVertex.invalidateAdjacentCellInformation();

  assertion4(
    localVertex.getRefinementControl() != Vertex::Records::Erasing,
    localVertex.toString(), masterVertex.toString(), tarch::parallel::NodePool::getInstance().getMasterRank(), tarch::parallel::Node::getInstance().getRank()
  );

  logTraceOutWith1Argument( "mergeWithForkedVertexFromMaster(...)", localVertex );
}


template <class Cell>
void peano::grid::aspects::ParallelMerge::mergeWithForkedCellFromMaster(
  Cell&        localCell,
  const Cell&  masterCell
) {
  logTraceInWith2Arguments( "mergeWithForkedCellFromMaster(...)", localCell, masterCell );

  #if defined(Asserts) && defined(Parallel)
  assertionEquals3( localCell._cellData.getEvenFlags(),    masterCell._cellData.getEvenFlags(),    localCell.toString(), masterCell.toString(), tarch::parallel::NodePool::getInstance().getMasterRank() );
  assertionEquals3( localCell._cellData.getAccessNumber(), masterCell._cellData.getAccessNumber(), localCell.toString(), masterCell.toString(), tarch::parallel::NodePool::getInstance().getMasterRank() );

  #ifdef Debug // if we are not in debug mode, these values are not available.
  assertionEquals3( localCell._cellData.getLevel(),        masterCell._cellData.getLevel(),        localCell.toString(), masterCell.toString(), tarch::parallel::NodePool::getInstance().getMasterRank() );
  #endif
  #endif

  const bool MasterIsRefinedLocalCellIsNot = masterCell.isRefined() && !localCell.isRefined();


  localCell._cellData.setIsInside( masterCell._cellData.getIsInside() );
  localCell._cellData.setState(    masterCell._cellData.getState() );
  localCell._cellData.setEvenFlags(    masterCell._cellData.getEvenFlags() );
  localCell._cellData.setAccessNumber(    masterCell._cellData.getAccessNumber() );
  localCell._cellData.setResponsibleRank(    masterCell._cellData.getResponsibleRank() );

  #ifdef Debug
  localCell._cellData.setLevel(    masterCell._cellData.getLevel() );
  #endif

  #ifdef SharedMemoryParallelisation
  localCell.clearInputOutputStackAccessStatistics();
  #endif

  localCell.setRemoteCellWorkloadAndSubtreeFlags( masterCell );

  if (MasterIsRefinedLocalCellIsNot) {
    localCell._cellData.setState( Cell::Records::Leaf );
  }

  if ( localCell.isAssignedToRemoteRank() ) {
    localCell._cellData.setResponsibleRank( tarch::parallel::NodePool::getInstance().getMasterRank() );
  }

  logTraceOutWith1Argument( "mergeWithForkedCellFromMaster(...)", localCell );
}


template <class Cell>
bool peano::grid::aspects::ParallelMerge::mergeWithJoinedCellFromWorker(
  Cell&        localCell,
  const Cell&  workerCell,
  int          workerRank
) {
  logTraceInWith3Arguments( "mergeWithJoinedCellFromWorker(...)", localCell, workerCell, workerRank );

  #if !defined(Parallel)
  const bool result = false;
  #else
  assertionEquals4( localCell._cellData.getEvenFlags(),    workerCell._cellData.getEvenFlags(),    localCell.toString(), workerCell.toString(), workerRank, tarch::parallel::NodePool::getInstance().getMasterRank() );
  assertionEquals4( localCell._cellData.getAccessNumber(), workerCell._cellData.getAccessNumber(), localCell.toString(), workerCell.toString(), workerRank, tarch::parallel::NodePool::getInstance().getMasterRank() );

  #ifdef Debug // if we are not in debug mode, these values are not available.
  assertionEquals4( localCell._cellData.getLevel(),        workerCell._cellData.getLevel(),        localCell.toString(), workerCell.toString(), workerRank, tarch::parallel::NodePool::getInstance().getMasterRank() );
  #endif

  const bool WorkerJoinsThisElementToLocalRank  = workerCell._cellData.getResponsibleRank() == workerRank;
  const bool WorkerIsRefinedLocalCellIsNot      = workerCell.isRefined() && !localCell.isRefined();
  const bool result                             = !localCell._cellData.getIsInside() && workerCell._cellData.getIsInside();

  assertion5(
    !WorkerJoinsThisElementToLocalRank || localCell._cellData.getIsInside()==workerCell._cellData.getIsInside(),
    localCell.toString(),
    workerCell.toString(),
    workerRank,
    tarch::parallel::Node::getInstance().getRank(),
    tarch::parallel::NodePool::getInstance().getMasterRank()
  );
  assertion5(
    !WorkerIsRefinedLocalCellIsNot || WorkerJoinsThisElementToLocalRank || !WorkerJoinsThisElementToLocalRank,
    localCell.toString(), workerCell.toString(),
    workerRank,
    tarch::parallel::Node::getInstance().getRank(),
    tarch::parallel::NodePool::getInstance().getMasterRank()
  );
  assertion5(
    !WorkerJoinsThisElementToLocalRank || workerCell._cellData.getResponsibleRank() == localCell._cellData.getResponsibleRank(),
    localCell.toString(), workerCell.toString(),
    workerRank,
    tarch::parallel::Node::getInstance().getRank(),
    tarch::parallel::NodePool::getInstance().getMasterRank()
  );

  if (WorkerJoinsThisElementToLocalRank) {
    localCell._cellData.setResponsibleRank(    workerCell._cellData.getResponsibleRank() );
  }

  #ifdef SharedMemoryParallelisation
  localCell.clearInputOutputStackAccessStatistics();
  #endif

  localCell.setRemoteCellWorkloadAndSubtreeFlags( workerCell );

  if (WorkerIsRefinedLocalCellIsNot) {
    localCell._cellData.setState( Cell::Records::Leaf );
  }
  #endif

  logTraceOutWith2Arguments( "mergeWithJoinedCellFromWorker(...)", localCell, result );
  return result;
}
