#include "peano/grid/SingleLevelEnumerator.h"

#include "tarch/parallel/NodePool.h"


template <class Vertex>
void peano::grid::aspects::ParallelMerge::mergeOnDomainBoundary(
  Vertex&        localVertex,
  const Vertex&  neighbourVertex
) {
  logTraceInWith2Arguments( "mergeOnDomainBoundary(...)", localVertex, neighbourVertex );

  #ifdef Debug // if we are not in debug mode, these values are not available.
  assertionVectorNumericalEquals2( localVertex._vertexData.getX(), neighbourVertex._vertexData.getX(),     localVertex.toString(), neighbourVertex.toString() );
  assertionEquals2( localVertex._vertexData.getLevel(),            neighbourVertex._vertexData.getLevel(), localVertex.toString(), neighbourVertex.toString() );
  #endif

  assertionEquals2( localVertex._vertexData.getInsideOutsideDomain(), neighbourVertex._vertexData.getInsideOutsideDomain(), localVertex.toString(), neighbourVertex.toString() );
  assertion1( !localVertex.isHangingNode(),                           localVertex.toString() );

  assertion3( localVertex.getRefinementControl()!=Vertex::Records::Erasing ,                                    localVertex.toString(), neighbourVertex.toString(), tarch::parallel::Node::getInstance().getRank()  );
  assertion3( localVertex.getRefinementControl()!=Vertex::Records::Refining,                                    localVertex.toString(), neighbourVertex.toString(), tarch::parallel::Node::getInstance().getRank()  );
  assertion3( localVertex.getRefinementControl()!=Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing, localVertex.toString(), neighbourVertex.toString(), tarch::parallel::Node::getInstance().getRank()  );

  const bool OnlyNeighbourHasTriggeredRefinement =
    neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::RefinementTriggered &&
    localVertex._vertexData.getRefinementControl()==Vertex::Records::Unrefined;
  const bool OnlyNeighbourHasTriggeredErase =
    neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::EraseTriggered &&
    localVertex._vertexData.getRefinementControl()==Vertex::Records::Refined;
  const bool OnlyLocalHasTriggeredRefinement =
    localVertex._vertexData.getRefinementControl()==Vertex::Records::RefinementTriggered &&
    neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::Unrefined;
  const bool OnlyLocalHasTriggeredErase =
    localVertex._vertexData.getRefinementControl()==Vertex::Records::EraseTriggered &&
    neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::Refined;

  if (OnlyNeighbourHasTriggeredRefinement || OnlyLocalHasTriggeredRefinement) {
    localVertex._vertexData.setRefinementControl( Vertex::Records::RefinementTriggered );
  }
  else if (OnlyNeighbourHasTriggeredErase || OnlyLocalHasTriggeredErase) {
    localVertex._vertexData.setRefinementControl( Vertex::Records::EraseTriggered );
  }
  else {
    assertion2(
         (localVertex._vertexData.getRefinementControl()==neighbourVertex._vertexData.getRefinementControl())
      || (localVertex._vertexData.getRefinementControl()==Vertex::Records::EraseTriggered && neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::Refining)
//      || (localVertex._vertexData.getRefinementControl()==Vertex::Records::RefinementTriggered && neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::Erasing)
      || (localVertex._vertexData.getRefinementControl()==Vertex::Records::Refined && neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::Refining)
      || (localVertex._vertexData.getRefinementControl()==Vertex::Records::Unrefined && neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::Erasing)
      || (localVertex._vertexData.getRefinementControl()==Vertex::Records::Unrefined && neighbourVertex._vertexData.getRefinementControl()==Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing)
      , localVertex.toString(), neighbourVertex.toString()
    );
  }

  localVertex._vertexData.setNumberOfAdjacentRefinedCells( neighbourVertex._vertexData.getNumberOfAdjacentRefinedCells() );

  logTraceOutWith1Argument( "mergeOnDomainBoundary(...)", localVertex );
}


template <class Vertex>
peano::grid::aspects::ParallelMerge::MergeVertexDueToJoinEffect
peano::grid::aspects::ParallelMerge::mergeWithJoinedVertexFromWorker(
  Vertex&        localVertex,
  const Vertex&  workerVertex,
  int            workerRank
) {
  logTraceInWith2Arguments( "mergeWithJoinedVertexFromWorker(...)", localVertex, workerVertex );

  MergeVertexDueToJoinEffect result = MasterVertexStateRemainsUnaltered;

  #if defined(Parallel)
  const bool LocalNodeHasNotBeenResponsibleBefore = !localVertex.isAdjacentToDomainOf( tarch::parallel::Node::getInstance().getRank() );

  assertionVectorNumericalEquals2( localVertex._vertexData.getX(), workerVertex._vertexData.getX(),     localVertex.toString(), workerVertex.toString() );
  assertionEquals2( localVertex._vertexData.getLevel(),            workerVertex._vertexData.getLevel(), localVertex.toString(), workerVertex.toString() );

  assertion2( localVertex.isHangingNode() || localVertex._vertexData.getAdjacentCellsHeightOfPreviousIteration() <= -2,  localVertex.toString(), workerVertex.toString() );
  assertion2( localVertex.isHangingNode() || localVertex._vertexData.getAdjacentCellsHeight()                    <= -2,  localVertex.toString(), workerVertex.toString() );
  assertion3( workerVertex.isHangingNode() || workerVertex._vertexData.getAdjacentCellsHeightOfPreviousIteration() <= -2, localVertex.toString(), workerVertex.toString(), toString(static_cast<peano::grid::CellFlags>(workerVertex._vertexData.getAdjacentCellsHeightOfPreviousIteration())) );
  assertion2( workerVertex.isHangingNode() || workerVertex._vertexData.getAdjacentCellsHeight()                    <= -2, localVertex.toString(), workerVertex.toString() );
  assertionEquals2( workerVertex.isHangingNode(), localVertex.isHangingNode(), localVertex.toString(), workerVertex.toString() );

  assertion4(
    LocalNodeHasNotBeenResponsibleBefore ||
    localVertex._vertexData.getInsideOutsideDomain() == workerVertex._vertexData.getInsideOutsideDomain(),
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );

  assertion4(
    workerVertex.getRefinementControl()!=Vertex::Records::EraseTriggered,
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );
  assertion4(
    workerVertex.getRefinementControl()!=Vertex::Records::RefinementTriggered,
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );

  const bool  workerIsRefinedLocalVertexIsNot  =
    workerVertex.getRefinementControl()!=Vertex::Records::Unrefined &&
    workerVertex.getRefinementControl()!=Vertex::Records::Erasing &&
    localVertex.getRefinementControl()!=Vertex::Records::Refined;

  const bool  vertexHasToBeRefinedTemporary =
    workerVertex.getRefinementControl()==Vertex::Records::Erasing &&
    localVertex.getRefinementControl()!=Vertex::Records::Refined &&
    localVertex.getRefinementControl()!=Vertex::Records::Erasing;

  assertion4(
    workerVertex.getRefinementControl()!=Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing,
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );
  assertion4(
    !(workerVertex.getRefinementControl()==Vertex::Records::Erasing && localVertex.getRefinementControl()==Vertex::Records::Refining),
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );
  assertion4(
    !(workerVertex.getRefinementControl()==Vertex::Records::Refining && localVertex.getRefinementControl()==Vertex::Records::Erasing),
    localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
  );

  localVertex._vertexData.setIsHangingNode(       workerVertex._vertexData.getIsHangingNode() );
  localVertex._vertexData.setRefinementControl(   workerVertex._vertexData.getRefinementControl() );

  #ifdef Debug
  localVertex._vertexData.setX( workerVertex._vertexData.getX() );
  localVertex._vertexData.setLevel( workerVertex._vertexData.getLevel() );
  #endif

  if (LocalNodeHasNotBeenResponsibleBefore) {
    if (workerVertex.isInside() && localVertex.isOutside()) {
      result = CreateInnerVertexOnMaster;
    }
    if (workerVertex.isBoundary() && localVertex.isOutside()) {
      result = CreateBoundaryVertexOnMaster;
    }

    for (int i=0; i<TWO_POWER_D; i++) {
      const bool entriesAreEqual  = localVertex._vertexData.getAdjacentRanks(i)  == workerVertex._vertexData.getAdjacentRanks(i);
      const bool workersEntryIsMe = workerVertex._vertexData.getAdjacentRanks(i) == tarch::parallel::Node::getInstance().getRank();
      if ( !entriesAreEqual && !workersEntryIsMe) {
        localVertex._vertexData.setAdjacentRanks( i, workerVertex._vertexData.getAdjacentRanks(i) );
      }
      else if (!entriesAreEqual) {
        localVertex._vertexData.setAdjacentRanks( i, workerRank );
      }
    }
  }
  else {
    assertionEquals2( localVertex._vertexData.getInsideOutsideDomain(), workerVertex._vertexData.getInsideOutsideDomain(), localVertex.toString(), workerVertex.toString() );
  }

  if (vertexHasToBeRefinedTemporary) {
    assertion4(
      workerVertex.getRefinementControl()==Vertex::Records::Unrefined ||
      workerVertex.getRefinementControl()==Vertex::Records::Erasing,
      localVertex.toString(), workerVertex.toString(), workerRank, tarch::parallel::Node::getInstance().getRank()
    );
    localVertex._vertexData.setRefinementControl(Vertex::Records::RefineDueToJoinThoughWorkerIsAlreadyErasing);
    logDebug( "mergeWithJoinedVertexFromWorker(...)", "merged local vertex with " << workerVertex.toString() << " and got " << localVertex.toString() );
  }
  else if (workerIsRefinedLocalVertexIsNot) {
    localVertex._vertexData.setRefinementControl( Vertex::Records::Refining );
  }

  localVertex.invalidateAdjacentCellInformation();
  #endif

  logTraceOutWith2Arguments( "mergeWithJoinedVertexFromWorker(...)", localVertex, result );
  return result;
}


template <class Vertex>
void peano::grid::aspects::ParallelMerge::mergeWithForkedVertexFromMaster(
  Vertex&        localVertex,
  const Vertex&  masterVertex
) {
  logTraceInWith2Arguments( "mergeWithForkedVertexFromMaster(...)", localVertex, masterVertex );

  #if defined(Parallel)
  const bool MasterIsNotResponsibleAnymore = !masterVertex.isAdjacentToDomainOf( tarch::parallel::NodePool::getInstance().getMasterRank() );

  #ifdef Debug // if we are not in debug mode, these values are not available.
  assertionVectorNumericalEquals2( localVertex._vertexData.getX(),                        masterVertex._vertexData.getX(),                                      localVertex.toString(), masterVertex.toString() );
  assertionEquals2( localVertex._vertexData.getLevel(),                                   masterVertex._vertexData.getLevel(),                                  localVertex.toString(), masterVertex.toString() );
  #endif

  assertion2( localVertex.isHangingNode() || localVertex._vertexData.getAdjacentCellsHeightOfPreviousIteration() <= -2,  localVertex.toString(), masterVertex.toString() );
  assertion2( localVertex.isHangingNode() || localVertex._vertexData.getAdjacentCellsHeight()                    <= -2,  localVertex.toString(), masterVertex.toString() );
  assertion3( masterVertex.isHangingNode() || masterVertex._vertexData.getAdjacentCellsHeightOfPreviousIteration() <= -2, localVertex.toString(), masterVertex.toString(), toString(static_cast<peano::grid::CellFlags>(masterVertex._vertexData.getAdjacentCellsHeightOfPreviousIteration())) );
  assertion2( masterVertex.isHangingNode() || masterVertex._vertexData.getAdjacentCellsHeight()                    <= -2, localVertex.toString(), masterVertex.toString() );
  assertionEquals2( masterVertex.isHangingNode(), localVertex.isHangingNode(), localVertex.toString(), masterVertex.toString() );

  assertion4(
    MasterIsNotResponsibleAnymore ||
    localVertex._vertexData.getInsideOutsideDomain() == masterVertex._vertexData.getInsideOutsideDomain(),
    localVertex.toString(), masterVertex.toString(), tarch::parallel::NodePool::getInstance().getMasterRank(), tarch::parallel::Node::getInstance().getRank()
  );

  assertion2( masterVertex.isAdjacentToDomainOf(tarch::parallel::Node::getInstance().getRank()), masterVertex.toString(), localVertex.toString() );

  const bool                                          masterIsRefinedLocalVertexIsNot  = masterVertex.getRefinementControl()==Vertex::Records::Refined && localVertex.getRefinementControl()!=Vertex::Records::Refined;
  const bool                                          workerIsRefiningOrTriggeredRefinementWhileMasterVertexIsUnrefined  =
    (localVertex.getRefinementControl()==Vertex::Records::Refining || localVertex.getRefinementControl()==Vertex::Records::RefinementTriggered) &&
    (masterVertex.getRefinementControl()==Vertex::Records::Unrefined || masterVertex.getRefinementControl()==Vertex::Records::Erasing);

  const typename Vertex::Records::InsideOutsideDomain insideOutsideDomainOfLocalVertex = localVertex._vertexData.getInsideOutsideDomain();

  assertion3(
    !workerIsRefiningOrTriggeredRefinementWhileMasterVertexIsUnrefined || MasterIsNotResponsibleAnymore,
    masterVertex.toString(),
    localVertex.toString(),
    tarch::parallel::Node::getInstance().getRank()
  );

  localVertex._vertexData.setIsHangingNode(       masterVertex._vertexData.getIsHangingNode() );
  localVertex._vertexData.setRefinementControl(   masterVertex._vertexData.getRefinementControl() );
  localVertex._vertexData.setInsideOutsideDomain( masterVertex._vertexData.getInsideOutsideDomain() );
  localVertex._vertexData.setAdjacentRanks(       masterVertex._vertexData.getAdjacentRanks() );

  #ifdef Debug
  localVertex._vertexData.setX( masterVertex._vertexData.getX() );
  localVertex._vertexData.setLevel( masterVertex._vertexData.getLevel() );
  #endif

  if (MasterIsNotResponsibleAnymore) {
    localVertex._vertexData.setInsideOutsideDomain(insideOutsideDomainOfLocalVertex);
  }
  else {
    assertionEquals2( localVertex._vertexData.getInsideOutsideDomain(), masterVertex._vertexData.getInsideOutsideDomain(),                    localVertex.toString(), masterVertex.toString() );
  }

  if (masterIsRefinedLocalVertexIsNot) {
    localVertex._vertexData.setRefinementControl( Vertex::Records::Refining );
  }
  else if (workerIsRefiningOrTriggeredRefinementWhileMasterVertexIsUnrefined) {
    // the local vertex was already refining. That can happen if and only if
    // the create event has triggered a refinement. In that case, Peano tries
    // to refine immediately, i.e. not in two sweeps. As we are forking however
    // we have disable this immediate refine here manually - the master did not
    // do the same thing, as the vertex is already remote on the master. So we
    // reset the refining to refinement-triggered.
    localVertex._vertexData.setRefinementControl( Vertex::Records::RefinementTriggered );
    logDebug( "mergeWithForkedVertexFromMaster(...)","manually reset refinement state of " << localVertex.toString() );
  }

  localVertex.invalidateAdjacentCellInformation();
  #endif

  logTraceOutWith1Argument( "mergeWithForkedVertexFromMaster(...)", localVertex );
}


template <class Cell>
void peano::grid::aspects::ParallelMerge::mergeWithForkedCellFromMaster(
  Cell&        localCell,
  const Cell&  masterCell
) {
  logTraceInWith2Arguments( "mergeWithForkedCellFromMaster(...)", localCell, masterCell );

  #if defined(Asserts) && defined(Parallel)
  assertionEquals3( localCell._cellData.getEvenFlags(),    masterCell._cellData.getEvenFlags(),    localCell.toString(), masterCell.toString(), tarch::parallel::NodePool::getInstance().getMasterRank() );
  assertionEquals3( localCell._cellData.getAccessNumber(), masterCell._cellData.getAccessNumber(), localCell.toString(), masterCell.toString(), tarch::parallel::NodePool::getInstance().getMasterRank() );

  #ifdef Debug // if we are not in debug mode, these values are not available.
  assertionEquals3( localCell._cellData.getLevel(),        masterCell._cellData.getLevel(),        localCell.toString(), masterCell.toString(), tarch::parallel::NodePool::getInstance().getMasterRank() );
  #endif
  #endif

  const bool MasterIsRefinedLocalCellIsNot = masterCell.isRefined() && !localCell.isRefined();


  localCell._cellData.setIsInside( masterCell._cellData.getIsInside() );
  localCell._cellData.setState(    masterCell._cellData.getState() );
  localCell._cellData.setEvenFlags(    masterCell._cellData.getEvenFlags() );
  localCell._cellData.setAccessNumber(    masterCell._cellData.getAccessNumber() );
  localCell._cellData.setResponsibleRank(    masterCell._cellData.getResponsibleRank() );

  #ifdef Debug
  localCell._cellData.setLevel(    masterCell._cellData.getLevel() );
  #endif

  #ifdef SharedMemoryParallelisation
  localCell.clearInputOutputStackAccessStatistics();
  #endif


  if (MasterIsRefinedLocalCellIsNot) {
    localCell._cellData.setState( Cell::Records::Leaf );
  }

  if ( localCell.isAssignedToRemoteRank() ) {
    localCell._cellData.setResponsibleRank( tarch::parallel::NodePool::getInstance().getMasterRank() );
  }

  logTraceOutWith1Argument( "mergeWithForkedCellFromMaster(...)", localCell );
}


template <class Cell>
bool peano::grid::aspects::ParallelMerge::mergeWithJoinedCellFromWorker(
  Cell&        localCell,
  const Cell&  workerCell,
  int          workerRank
) {
  logTraceInWith2Arguments( "mergeWithJoinedCellFromWorker(...)", localCell, workerCell );

  #if !defined(Parallel)
  const bool result = false;
  #else
  assertionEquals4( localCell._cellData.getEvenFlags(),    workerCell._cellData.getEvenFlags(),    localCell.toString(), workerCell.toString(), workerRank, tarch::parallel::NodePool::getInstance().getMasterRank() );
  assertionEquals4( localCell._cellData.getAccessNumber(), workerCell._cellData.getAccessNumber(), localCell.toString(), workerCell.toString(), workerRank, tarch::parallel::NodePool::getInstance().getMasterRank() );

  #ifdef Debug // if we are not in debug mode, these values are not available.
  assertionEquals4( localCell._cellData.getLevel(),        workerCell._cellData.getLevel(),        localCell.toString(), workerCell.toString(), workerRank, tarch::parallel::NodePool::getInstance().getMasterRank() );
  #endif

  const bool WorkerJoinsThisElementToLocalRank  = workerCell._cellData.getResponsibleRank() == workerRank;
  const bool WorkerIsRefinedLocalCellIsNot      = workerCell.isRefined() && !localCell.isRefined();
  const bool result                             = !localCell._cellData.getIsInside() && workerCell._cellData.getIsInside();

  assertion5(
    !WorkerJoinsThisElementToLocalRank || localCell._cellData.getIsInside()==workerCell._cellData.getIsInside(),
    localCell.toString(),
    workerCell.toString(),
    workerRank,
    tarch::parallel::Node::getInstance().getRank(),
    tarch::parallel::NodePool::getInstance().getMasterRank()
  );
  assertion5(
    !WorkerIsRefinedLocalCellIsNot || WorkerJoinsThisElementToLocalRank || !WorkerJoinsThisElementToLocalRank,
    localCell.toString(), workerCell.toString(),
    workerRank,
    tarch::parallel::Node::getInstance().getRank(),
    tarch::parallel::NodePool::getInstance().getMasterRank()
  );

  assertion5(
    !WorkerJoinsThisElementToLocalRank || workerCell._cellData.getResponsibleRank() == localCell._cellData.getResponsibleRank(),
    localCell.toString(), workerCell.toString(),
    workerRank,
    tarch::parallel::Node::getInstance().getRank(),
    tarch::parallel::NodePool::getInstance().getMasterRank()
  );


  if (WorkerJoinsThisElementToLocalRank) {
    localCell._cellData.setResponsibleRank(    workerCell._cellData.getResponsibleRank() );
  }

  #ifdef SharedMemoryParallelisation
  localCell.clearInputOutputStackAccessStatistics();
  #endif

  if (WorkerIsRefinedLocalCellIsNot) {
    localCell._cellData.setState( Cell::Records::Leaf );
  }
  #endif

  logTraceOutWith2Arguments( "mergeWithJoinedCellFromWorker(...)", localCell, result );
  return result;
}
