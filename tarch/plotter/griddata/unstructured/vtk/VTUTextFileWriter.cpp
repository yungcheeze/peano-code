#include "tarch/plotter/griddata/unstructured/vtk/VTUTextFileWriter.h"

#include "tarch/parallel/NodePool.h"

#include <stdio.h>
#include <fstream>
#include <iomanip>

tarch::logging::Log tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::_log( "tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter" );


const std::string tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::HEADER =
"<?xml version=\"1.0\"?>\n\
<!-- Generated by Peano3 output component $Revision: 1.2 $ Author: Tobias Weinzierl -->\n";


tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::VTUTextFileWriter(const int precision):
  _dataType(precision < 7 ? "Float32" : "Float64"),
  _writtenToFile(false),
  _numberOfVertices(0),
  _numberOfCells(0) {}


tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::~VTUTextFileWriter() {
  if (!_writtenToFile) {
    assertionEqualsMsg( _numberOfVertices,    0, "Still vertices in vtk writer pipeline. Maybe you forgot to call writeToFile() on a data vtk writer?" );
    assertionEqualsMsg( _numberOfCells,       0, "Still cells in vtk writer pipeline. Maybe you forgot to call writeToFile() on a data vtk writer?" );
  }
}


void tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::clear() {
  _writtenToFile       = false;
  _numberOfVertices    = 0;
  _numberOfCells       = 0;
  _vertexDescription      = "";
  _cellDescription        = "";
  _vertexDataDescription  = "";
  _cellDataDescription    = "";
  _parallelVertexDataDescription = "";
  _parallelCellDataDescription   = "";
}


bool tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::writeToFile( const std::string& filenamePrefix ) {
  assertion( !_writtenToFile );

  if (filenamePrefix.rfind(".vtu")!=std::string::npos) {
    logWarning( "writeToFile()", "filename should not end with .vtu as routine adds extension automatically. Chosen filename prefix=" << filenamePrefix );
  }
  std::ostringstream filenameStream;
  filenameStream << filenamePrefix
    #ifdef Parallel
                 << "-rank-" << tarch::parallel::Node::getInstance().getRank()
    #endif
                 << ".vtu";
  const std::string filename = filenameStream.str();

  std::ofstream out;
  out.open( filename.c_str() );
  if ( (!out.fail()) && out.is_open() ) {
    _log.debug( "close()", "opened data file " + filename );

    out << HEADER << std::endl << std::endl
        << "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">" << std::endl
        << "<UnstructuredGrid>" << std::endl
        << "<Piece NumberOfPoints=\"" << _numberOfVertices << "\" NumberOfCells=\"" << _numberOfCells << "\">" << std::endl
        << _vertexDescription << std::endl
        << _cellDescription << std::endl
        <<  "<PointData>" << std::endl
        << _vertexDataDescription << std::endl
        << "</PointData>" << std::endl
        << "<CellData>" << std::endl
        << _cellDataDescription << std::endl
        << "</CellData>\n\
        </Piece>\n\
      </UnstructuredGrid>\n\
    </VTKFile>\n";

    _log.debug( "close()", "data written to " + filename );
    _writtenToFile = true;
  }
  else {
  	_log.error( "close()", "unable to write output file " + filename );
  	return false;
  }

  #ifdef Parallel
  if (tarch::parallel::Node::getInstance().isGlobalMaster()) {
    std::string parallelMetaFileName = filenamePrefix + ".pvtu";

    std::ofstream metaOut;
    metaOut.open( parallelMetaFileName.c_str() );
    if ( (!metaOut.fail()) && metaOut.is_open() ) {
      _log.debug( "close()", "opened data file " + filename );

      metaOut << "<?xml version=\"1.0\"?>" << std::endl
              << "<VTKFile type=\"PUnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">" << std::endl
              << "<PUnstructuredGrid GhostLevel=\"0\">" << std::endl
            << "<PPoints>" << std::endl
            << "<PDataArray type=\"" << _dataType << "\" Name=\"coordinates\" NumberOfComponents=\"3\"/>" << std::endl
            << "</PPoints>" << std::endl
            << "<PCells>" << std::endl
            << "<PDataArray type=\"Int32\" Name=\"connectivity\" NumberOfComponents=\"1\"/>" << std::endl
            << "<PDataArray type=\"Int32\" Name=\"offsets\"      NumberOfComponents=\"1\"/>" << std::endl
            << "<PDataArray type=\"UInt8\" Name=\"types\"        NumberOfComponents=\"1\"/>" << std::endl
            << "</PCells>" << std::endl
            << "<PPointData>" << std::endl
            << _parallelVertexDataDescription << std::endl
            << "</PPointData>" << std::endl
            << "<PCellData>" << std::endl
            << _parallelCellDataDescription << std::endl
            << "</PCellData>" << std::endl
      /*
    <PPointData Scalars="composition">
      <PDataArray type="Float32" Name="pressure" NumberOfComponents="1"/>
      <PDataArray type="Float32" Name="composition"
NumberOfComponents="1"/>
      <PDataArray type="Float32" Name="velocity" NumberOfComponents="3"/>
      <PDataArray type="Float32" Name="force" NumberOfComponents="3"/>
    </PPointData>
*/
              ;
//            << "Piece Source="circ_inc-0_0.vtu"/>

      for (int i=0; i<tarch::parallel::Node::getInstance().getNumberOfNodes(); i++) {
        if ( i==0 || !tarch::parallel::NodePool::getInstance().isIdleNode(i) ) {
          std::ostringstream referencedFilename;
          if (filenamePrefix.find("/")!=std::string::npos) {
            referencedFilename << filenamePrefix.substr( filenamePrefix.rfind("/")+1 );
          }
          else {
            referencedFilename << filenamePrefix;
          }
          referencedFilename << "-rank-" << i
                             << ".vtu";
          metaOut << "<Piece Source=\"" << referencedFilename.str() << "\"/>" << std::endl;
        }
      }

      metaOut << "</PUnstructuredGrid>" << std::endl
                << "</VTKFile>" << std::endl;

      metaOut.close();
    }
    else {
      _log.error( "close()", "unable to write meta data file " + parallelMetaFileName );
      return false;
    }
  }
  #endif

  return true;
}


bool tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::isOpen() {
  return !_writtenToFile;
}


tarch::plotter::griddata::unstructured::UnstructuredGridWriter::VertexWriter*
tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::createVertexWriter() {
  return new tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::VertexWriter(*this,_dataType);
}


tarch::plotter::griddata::unstructured::UnstructuredGridWriter::CellWriter*
tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::createCellWriter() {
  return new tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::CellWriter(*this,_dataType);
}


void tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::validateDataWriterIdentifier( const std::string& identifier ) const {
  if (identifier.empty()) {
    logWarning(
      "validateDataWriterIdentifier(string)",
      "identifier for vtk file is empty. Spaces are not allowed for vtk data field identifiers and some vtk visualisers might crash."
    );
  }
  if (identifier.find(' ')!=std::string::npos) {
    logWarning(
      "validateDataWriterIdentifier(string)",
      "identifier \"" << identifier << "\" contains spaces. Spaces are not allowed for vtk data field identifiers and some vtk visualisers might crash."
    );
  }
}


tarch::plotter::griddata::Writer::CellDataWriter*    tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::createCellDataWriter( const std::string& identifier, int recordsPerCell ) {
  validateDataWriterIdentifier(identifier);
  return new tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::CellDataWriter(identifier,*this, recordsPerCell, _dataType);
}


tarch::plotter::griddata::Writer::VertexDataWriter*  tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::createVertexDataWriter( const std::string& identifier, int recordsPerVertex ) {
  validateDataWriterIdentifier(identifier);
  return new tarch::plotter::griddata::unstructured::vtk::VTUTextFileWriter::VertexDataWriter(identifier,*this, recordsPerVertex, _dataType);
}
